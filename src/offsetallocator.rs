/* automatically generated by rust-bindgen 0.69.5 */

pub type NodeIndex = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Allocation {
    pub offset: ::std::os::raw::c_uint,
    pub metadata: NodeIndex,
}
pub const Allocation_NO_SPACE: ::std::os::raw::c_uint = 4294967295;
#[test]
fn bindgen_test_layout_Allocation() {
    const UNINIT: ::std::mem::MaybeUninit<Allocation> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Allocation>(),
        8usize,
        concat!("Size of: ", stringify!(Allocation))
    );
    assert_eq!(
        ::std::mem::align_of::<Allocation>(),
        4usize,
        concat!("Alignment of ", stringify!(Allocation))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Allocation),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).metadata) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Allocation),
            "::",
            stringify!(metadata)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StorageReport {
    pub totalFreeSpace: ::std::os::raw::c_uint,
    pub largestFreeRegion: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_StorageReport() {
    const UNINIT: ::std::mem::MaybeUninit<StorageReport> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<StorageReport>(),
        8usize,
        concat!("Size of: ", stringify!(StorageReport))
    );
    assert_eq!(
        ::std::mem::align_of::<StorageReport>(),
        4usize,
        concat!("Alignment of ", stringify!(StorageReport))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).totalFreeSpace) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(StorageReport),
            "::",
            stringify!(totalFreeSpace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).largestFreeRegion) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(StorageReport),
            "::",
            stringify!(largestFreeRegion)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StorageReportFull {
    pub freeRegions: [StorageReportFull_Region; 256usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StorageReportFull_Region {
    pub size: ::std::os::raw::c_uint,
    pub count: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_StorageReportFull_Region() {
    const UNINIT: ::std::mem::MaybeUninit<StorageReportFull_Region> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<StorageReportFull_Region>(),
        8usize,
        concat!("Size of: ", stringify!(StorageReportFull_Region))
    );
    assert_eq!(
        ::std::mem::align_of::<StorageReportFull_Region>(),
        4usize,
        concat!("Alignment of ", stringify!(StorageReportFull_Region))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(StorageReportFull_Region),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(StorageReportFull_Region),
            "::",
            stringify!(count)
        )
    );
}
#[test]
fn bindgen_test_layout_StorageReportFull() {
    const UNINIT: ::std::mem::MaybeUninit<StorageReportFull> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<StorageReportFull>(),
        2048usize,
        concat!("Size of: ", stringify!(StorageReportFull))
    );
    assert_eq!(
        ::std::mem::align_of::<StorageReportFull>(),
        4usize,
        concat!("Alignment of ", stringify!(StorageReportFull))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).freeRegions) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(StorageReportFull),
            "::",
            stringify!(freeRegions)
        )
    );
}
#[repr(C)]
#[repr(align(8))]
pub struct Allocator {
    pub _bindgen_opaque_blob: [u64; 137usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Allocator_Node {
    pub dataOffset: ::std::os::raw::c_uint,
    pub dataSize: ::std::os::raw::c_uint,
    pub binListPrev: NodeIndex,
    pub binListNext: NodeIndex,
    pub neighborPrev: NodeIndex,
    pub neighborNext: NodeIndex,
    pub used: bool,
}
pub const Allocator_Node_unused: NodeIndex = 4294967295;
#[test]
fn bindgen_test_layout_Allocator_Node() {
    const UNINIT: ::std::mem::MaybeUninit<Allocator_Node> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Allocator_Node>(),
        28usize,
        concat!("Size of: ", stringify!(Allocator_Node))
    );
    assert_eq!(
        ::std::mem::align_of::<Allocator_Node>(),
        4usize,
        concat!("Alignment of ", stringify!(Allocator_Node))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Allocator_Node),
            "::",
            stringify!(dataOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataSize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Allocator_Node),
            "::",
            stringify!(dataSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).binListPrev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Allocator_Node),
            "::",
            stringify!(binListPrev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).binListNext) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Allocator_Node),
            "::",
            stringify!(binListNext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).neighborPrev) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Allocator_Node),
            "::",
            stringify!(neighborPrev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).neighborNext) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Allocator_Node),
            "::",
            stringify!(neighborNext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).used) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Allocator_Node),
            "::",
            stringify!(used)
        )
    );
}
#[test]
fn bindgen_test_layout_Allocator() {
    assert_eq!(
        ::std::mem::size_of::<Allocator>(),
        1096usize,
        concat!("Size of: ", stringify!(Allocator))
    );
    assert_eq!(
        ::std::mem::align_of::<Allocator>(),
        8usize,
        concat!("Alignment of ", stringify!(Allocator))
    );
}
extern "C" {
    #[link_name = "\u{1}?reset@Allocator@@QEAAXXZ"]
    pub fn Allocator_reset(this: *mut Allocator);
}
extern "C" {
    #[link_name = "\u{1}?allocate@Allocator@@QEAA?AUAllocation@@I@Z"]
    pub fn Allocator_allocate(this: *mut Allocator, size: ::std::os::raw::c_uint) -> Allocation;
}
extern "C" {
    #[link_name = "\u{1}?free@Allocator@@QEAAXUAllocation@@@Z"]
    pub fn Allocator_free(this: *mut Allocator, allocation: Allocation);
}
extern "C" {
    #[link_name = "\u{1}?allocationSize@Allocator@@QEBAIUAllocation@@@Z"]
    pub fn Allocator_allocationSize(
        this: *const Allocator,
        allocation: Allocation,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}?storageReport@Allocator@@QEBA?AUStorageReport@@XZ"]
    pub fn Allocator_storageReport(this: *const Allocator) -> StorageReport;
}
extern "C" {
    #[link_name = "\u{1}?storageReportFull@Allocator@@QEBA?AUStorageReportFull@@XZ"]
    pub fn Allocator_storageReportFull(this: *const Allocator) -> StorageReportFull;
}
extern "C" {
    #[link_name = "\u{1}??0Allocator@@QEAA@II@Z"]
    pub fn Allocator_Allocator(
        this: *mut Allocator,
        size: ::std::os::raw::c_uint,
        maxAllocs: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[link_name = "\u{1}??0Allocator@@QEAA@$$QEAV0@@Z"]
    pub fn Allocator_Allocator1(this: *mut Allocator, other: *mut Allocator);
}
extern "C" {
    #[link_name = "\u{1}??1Allocator@@QEAA@XZ"]
    pub fn Allocator_Allocator_destructor(this: *mut Allocator);
}
impl Allocator {
    #[inline]
    pub unsafe fn reset(&mut self) {
        Allocator_reset(self)
    }
    #[inline]
    pub unsafe fn allocate(&mut self, size: ::std::os::raw::c_uint) -> Allocation {
        Allocator_allocate(self, size)
    }
    #[inline]
    pub unsafe fn free(&mut self, allocation: Allocation) {
        Allocator_free(self, allocation)
    }
    #[inline]
    pub unsafe fn allocationSize(&self, allocation: Allocation) -> ::std::os::raw::c_uint {
        Allocator_allocationSize(self, allocation)
    }
    #[inline]
    pub unsafe fn storageReport(&self) -> StorageReport {
        Allocator_storageReport(self)
    }
    #[inline]
    pub unsafe fn storageReportFull(&self) -> StorageReportFull {
        Allocator_storageReportFull(self)
    }
    #[inline]
    pub unsafe fn new(size: ::std::os::raw::c_uint, maxAllocs: ::std::os::raw::c_uint) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Allocator_Allocator(__bindgen_tmp.as_mut_ptr(), size, maxAllocs);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(other: *mut Allocator) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Allocator_Allocator1(__bindgen_tmp.as_mut_ptr(), other);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        Allocator_Allocator_destructor(self)
    }
}
