/* automatically generated by rust-bindgen 0.69.5 */

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___1_allocator {
    pub _address: u8,
}
pub type std___1_allocator_size_type = u64;
pub type std___1_allocator_difference_type = u64;
pub type std___1_allocator_value_type = u8;
pub type std___1_allocator_propagate_on_container_move_assignment = u8;
pub type std___1_allocator_is_always_equal = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___1_vector {
    pub _address: u8,
}
pub type std___1_vector___default_allocator_type = u8;
pub type std___1_vector___self = u8;
pub type std___1_vector_value_type = u8;
pub type std___1_vector_allocator_type = u8;
pub type std___1_vector___alloc_traits = u8;
pub type std___1_vector_reference = u8;
pub type std___1_vector_const_reference = u8;
pub type std___1_vector_size_type = u8;
pub type std___1_vector_difference_type = u8;
pub type std___1_vector_pointer = u8;
pub type std___1_vector_const_pointer = u8;
pub type std___1_vector_iterator = u8;
pub type std___1_vector_const_iterator = u8;
pub type std___1_vector_reverse_iterator = u8;
pub type std___1_vector_const_reverse_iterator = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___1_vector___destroy_vector {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___1_vector__ConstructTransaction {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___1_complex {
    pub _address: u8,
}
pub type std___1_complex_value_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___1_list {
    pub _address: u8,
}
pub type std___1_list_base = u8;
pub type std___1_list___node_type = u8;
pub type std___1_list___node_allocator = u8;
pub type std___1_list___node_pointer = u8;
pub type std___1_list___node_alloc_traits = u8;
pub type std___1_list___node_base = u8;
pub type std___1_list___node_base_pointer = u8;
pub type std___1_list___link_pointer = u8;
pub type std___1_list_value_type = u8;
pub type std___1_list_allocator_type = u8;
pub type std___1_list_reference = u8;
pub type std___1_list_const_reference = u8;
pub type std___1_list_pointer = u8;
pub type std___1_list_const_pointer = u8;
pub type std___1_list_size_type = u8;
pub type std___1_list_difference_type = u8;
pub type std___1_list_iterator = u8;
pub type std___1_list_const_iterator = u8;
pub type std___1_list_reverse_iterator = u8;
pub type std___1_list_const_reverse_iterator = u8;
pub type std___1_list___remove_return_type = u8;
#[doc = " struct to represent tones"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Tone {
    #[doc = "< Frequency (Hz)"]
    pub freq: f64,
    #[doc = "< Level (dB)"]
    pub db: f64,
    #[doc = "< Stable level, useful for graphics rendering"]
    pub stabledb: f64,
    #[doc = "< Harmonics' levels"]
    pub harmonics: [f64; 48usize],
    #[doc = "< How many times the tone has been detected in row"]
    pub age: ::std::os::raw::c_ulong,
}
#[doc = "< The maximum number of harmonics tracked"]
pub const Tone_MAXHARM: ::std::os::raw::c_ulong = 48;
#[doc = "< The minimum age required for a tone to be output"]
pub const Tone_MINAGE: ::std::os::raw::c_ulong = 2;
#[test]
fn bindgen_test_layout_Tone() {
    const UNINIT: ::std::mem::MaybeUninit<Tone> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Tone>(),
        416usize,
        concat!("Size of: ", stringify!(Tone))
    );
    assert_eq!(
        ::std::mem::align_of::<Tone>(),
        8usize,
        concat!("Alignment of ", stringify!(Tone))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).freq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Tone),
            "::",
            stringify!(freq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).db) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Tone), "::", stringify!(db))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stabledb) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Tone),
            "::",
            stringify!(stabledb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).harmonics) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Tone),
            "::",
            stringify!(harmonics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).age) as usize - ptr as usize },
        408usize,
        concat!("Offset of field: ", stringify!(Tone), "::", stringify!(age))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN4ToneC1Ev"]
    pub fn Tone_Tone(this: *mut Tone);
}
impl Tone {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Tone_Tone(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}capacity"]
    pub static RingBuffer_capacity: usize;
}
#[doc = " analyzer class\n** class to analyze input audio and transform it into useable data\n*/"]
#[repr(C)]
pub struct Analyzer {
    pub m_step: ::std::os::raw::c_uint,
    pub m_buf: [u64; 2050usize],
    pub m_passthrough: [u64; 2050usize],
    pub m_resampleFactor: f64,
    pub m_resamplePos: f64,
    pub m_rate: f64,
    pub m_id: u32,
    pub m_window: [u64; 3usize],
    pub m_fft: Analyzer_fft_t,
    pub m_fftLastPhase: [u64; 3usize],
    pub m_peak: f64,
    pub m_tones: Analyzer_tones_t,
    pub m_oldfreq: f64,
}
#[doc = " fast fourier transform vector"]
pub type Analyzer_fft_t = [u64; 3usize];
#[doc = " list of tones"]
pub type Analyzer_tones_t = [u64; 3usize];
#[test]
fn bindgen_test_layout_Analyzer() {
    const UNINIT: ::std::mem::MaybeUninit<Analyzer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Analyzer>(),
        32952usize,
        concat!("Size of: ", stringify!(Analyzer))
    );
    assert_eq!(
        ::std::mem::align_of::<Analyzer>(),
        8usize,
        concat!("Alignment of ", stringify!(Analyzer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_step) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Analyzer),
            "::",
            stringify!(m_step)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_buf) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Analyzer),
            "::",
            stringify!(m_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_passthrough) as usize - ptr as usize },
        16408usize,
        concat!(
            "Offset of field: ",
            stringify!(Analyzer),
            "::",
            stringify!(m_passthrough)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_resampleFactor) as usize - ptr as usize },
        32808usize,
        concat!(
            "Offset of field: ",
            stringify!(Analyzer),
            "::",
            stringify!(m_resampleFactor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_resamplePos) as usize - ptr as usize },
        32816usize,
        concat!(
            "Offset of field: ",
            stringify!(Analyzer),
            "::",
            stringify!(m_resamplePos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rate) as usize - ptr as usize },
        32824usize,
        concat!(
            "Offset of field: ",
            stringify!(Analyzer),
            "::",
            stringify!(m_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_id) as usize - ptr as usize },
        32832usize,
        concat!(
            "Offset of field: ",
            stringify!(Analyzer),
            "::",
            stringify!(m_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_window) as usize - ptr as usize },
        32840usize,
        concat!(
            "Offset of field: ",
            stringify!(Analyzer),
            "::",
            stringify!(m_window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fft) as usize - ptr as usize },
        32864usize,
        concat!(
            "Offset of field: ",
            stringify!(Analyzer),
            "::",
            stringify!(m_fft)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fftLastPhase) as usize - ptr as usize },
        32888usize,
        concat!(
            "Offset of field: ",
            stringify!(Analyzer),
            "::",
            stringify!(m_fftLastPhase)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_peak) as usize - ptr as usize },
        32912usize,
        concat!(
            "Offset of field: ",
            stringify!(Analyzer),
            "::",
            stringify!(m_peak)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tones) as usize - ptr as usize },
        32920usize,
        concat!(
            "Offset of field: ",
            stringify!(Analyzer),
            "::",
            stringify!(m_tones)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_oldfreq) as usize - ptr as usize },
        32944usize,
        concat!(
            "Offset of field: ",
            stringify!(Analyzer),
            "::",
            stringify!(m_oldfreq)
        )
    );
}
extern "C" {
    #[doc = " Call this to process all data input so far."]
    #[link_name = "\u{1}__ZN8Analyzer7processEv"]
    pub fn Analyzer_process(this: *mut Analyzer);
}
extern "C" {
    #[doc = " Give data away for mic pass-through"]
    #[link_name = "\u{1}__ZN8Analyzer6outputEPfS0_d"]
    pub fn Analyzer_output(this: *mut Analyzer, begin: *mut f32, end: *mut f32, rate: f64) -> bool;
}
extern "C" {
    #[doc = " constructor"]
    #[link_name = "\u{1}__ZN8AnalyzerC1Edjj"]
    pub fn Analyzer_Analyzer(this: *mut Analyzer, rate: f64, id: u32, step: ::std::os::raw::c_uint);
}
impl Analyzer {
    #[inline]
    pub unsafe fn process(&mut self) {
        Analyzer_process(self)
    }
    #[inline]
    pub unsafe fn output(&mut self, begin: *mut f32, end: *mut f32, rate: f64) -> bool {
        Analyzer_output(self, begin, end, rate)
    }
    #[inline]
    pub unsafe fn new(rate: f64, id: u32, step: ::std::os::raw::c_uint) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Analyzer_Analyzer(__bindgen_tmp.as_mut_ptr(), rate, id, step);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct PtAKF {
    pub _AnalysisBuf: [u64; 2050usize],
    pub _Step: ::std::os::raw::c_uint,
    pub _VolTreshold: f32,
    pub _LastMaxVol: f32,
    pub _LastTones: [::std::os::raw::c_int; 3usize],
    pub _LastToneIndex: ::std::os::raw::c_int,
    pub _AKFValues: [f32; 4096usize],
}
extern "C" {
    #[link_name = "\u{1}__ZN5PtAKF10_InitCountE"]
    pub static mut PtAKF__InitCount: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN5PtAKF24_SamplesPerPeriodPerToneE"]
    pub static mut PtAKF__SamplesPerPeriodPerTone: *mut f32;
}
extern "C" {
    #[link_name = "\u{1}__ZN5PtAKF28_SamplesPerPeriodPerToneFineE"]
    pub static mut PtAKF__SamplesPerPeriodPerToneFine: *mut f32;
}
extern "C" {
    #[link_name = "\u{1}__ZN5PtAKF7_WindowE"]
    pub static mut PtAKF__Window: *mut f32;
}
pub const PtAKF__MaxHalfTone: ::std::os::raw::c_int = 56;
pub const PtAKF__HalfTonesAdd: ::std::os::raw::c_int = 4;
pub const PtAKF__MaxPeaks: ::std::os::raw::c_int = 10;
pub const PtAKF__SmoothCt: ::std::os::raw::c_int = 3;
pub const PtAKF__SampleCt: usize = 2048;
#[test]
fn bindgen_test_layout_PtAKF() {
    const UNINIT: ::std::mem::MaybeUninit<PtAKF> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PtAKF>(),
        32816usize,
        concat!("Size of: ", stringify!(PtAKF))
    );
    assert_eq!(
        ::std::mem::align_of::<PtAKF>(),
        8usize,
        concat!("Alignment of ", stringify!(PtAKF))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._AnalysisBuf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PtAKF),
            "::",
            stringify!(_AnalysisBuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._Step) as usize - ptr as usize },
        16400usize,
        concat!(
            "Offset of field: ",
            stringify!(PtAKF),
            "::",
            stringify!(_Step)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._VolTreshold) as usize - ptr as usize },
        16404usize,
        concat!(
            "Offset of field: ",
            stringify!(PtAKF),
            "::",
            stringify!(_VolTreshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._LastMaxVol) as usize - ptr as usize },
        16408usize,
        concat!(
            "Offset of field: ",
            stringify!(PtAKF),
            "::",
            stringify!(_LastMaxVol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._LastTones) as usize - ptr as usize },
        16412usize,
        concat!(
            "Offset of field: ",
            stringify!(PtAKF),
            "::",
            stringify!(_LastTones)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._LastToneIndex) as usize - ptr as usize },
        16424usize,
        concat!(
            "Offset of field: ",
            stringify!(PtAKF),
            "::",
            stringify!(_LastToneIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._AKFValues) as usize - ptr as usize },
        16428usize,
        concat!(
            "Offset of field: ",
            stringify!(PtAKF),
            "::",
            stringify!(_AKFValues)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN5PtAKF7GetNoteEPfS0_"]
    pub fn PtAKF_GetNote(
        this: *mut PtAKF,
        maxVolume: *mut f32,
        weights: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN5PtAKF18SetVolumeThresholdEf"]
    pub fn PtAKF_SetVolumeThreshold(this: *mut PtAKF, threshold: f32);
}
extern "C" {
    #[link_name = "\u{1}__ZN5PtAKFC1Ej"]
    pub fn PtAKF_PtAKF(this: *mut PtAKF, step: ::std::os::raw::c_uint);
}
extern "C" {
    #[link_name = "\u{1}__ZN5PtAKFD1Ev"]
    pub fn PtAKF_PtAKF_destructor(this: *mut PtAKF);
}
impl PtAKF {
    #[inline]
    pub unsafe fn GetNote(
        &mut self,
        maxVolume: *mut f32,
        weights: *mut f32,
    ) -> ::std::os::raw::c_int {
        PtAKF_GetNote(self, maxVolume, weights)
    }
    #[inline]
    pub unsafe fn SetVolumeThreshold(&mut self, threshold: f32) {
        PtAKF_SetVolumeThreshold(self, threshold)
    }
    #[inline]
    pub unsafe fn new(step: ::std::os::raw::c_uint) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        PtAKF_PtAKF(__bindgen_tmp.as_mut_ptr(), step);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        PtAKF_PtAKF_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _dywapitchtracker {
    pub _prevPitch: f64,
    pub _pitchConfidence: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__dywapitchtracker() {
    const UNINIT: ::std::mem::MaybeUninit<_dywapitchtracker> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_dywapitchtracker>(),
        16usize,
        concat!("Size of: ", stringify!(_dywapitchtracker))
    );
    assert_eq!(
        ::std::mem::align_of::<_dywapitchtracker>(),
        8usize,
        concat!("Alignment of ", stringify!(_dywapitchtracker))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._prevPitch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_dywapitchtracker),
            "::",
            stringify!(_prevPitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._pitchConfidence) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_dywapitchtracker),
            "::",
            stringify!(_pitchConfidence)
        )
    );
}
pub type dywapitchtracker = _dywapitchtracker;
#[repr(C)]
pub struct PtDyWa {
    pub _State: dywapitchtracker,
    pub _AnalysisBuf: [u64; 2050usize],
    pub _Step: ::std::os::raw::c_uint,
    pub _VolTreshold: f32,
    pub _LastMaxVol: f32,
}
pub const PtDyWa__SampleCt: usize = 2048;
#[test]
fn bindgen_test_layout_PtDyWa() {
    const UNINIT: ::std::mem::MaybeUninit<PtDyWa> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PtDyWa>(),
        16432usize,
        concat!("Size of: ", stringify!(PtDyWa))
    );
    assert_eq!(
        ::std::mem::align_of::<PtDyWa>(),
        8usize,
        concat!("Alignment of ", stringify!(PtDyWa))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._State) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PtDyWa),
            "::",
            stringify!(_State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._AnalysisBuf) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PtDyWa),
            "::",
            stringify!(_AnalysisBuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._Step) as usize - ptr as usize },
        16416usize,
        concat!(
            "Offset of field: ",
            stringify!(PtDyWa),
            "::",
            stringify!(_Step)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._VolTreshold) as usize - ptr as usize },
        16420usize,
        concat!(
            "Offset of field: ",
            stringify!(PtDyWa),
            "::",
            stringify!(_VolTreshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._LastMaxVol) as usize - ptr as usize },
        16424usize,
        concat!(
            "Offset of field: ",
            stringify!(PtDyWa),
            "::",
            stringify!(_LastMaxVol)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN6PtDyWa8FindNoteEPf"]
    pub fn PtDyWa_FindNote(this: *mut PtDyWa, maxVolume: *mut f32) -> f64;
}
extern "C" {
    #[link_name = "\u{1}__ZN6PtDyWa18SetVolumeThresholdEf"]
    pub fn PtDyWa_SetVolumeThreshold(this: *mut PtDyWa, threshold: f32);
}
extern "C" {
    #[link_name = "\u{1}__ZN6PtDyWaC1Ej"]
    pub fn PtDyWa_PtDyWa(this: *mut PtDyWa, step: ::std::os::raw::c_uint);
}
impl PtDyWa {
    #[inline]
    pub unsafe fn FindNote(&mut self, maxVolume: *mut f32) -> f64 {
        PtDyWa_FindNote(self, maxVolume)
    }
    #[inline]
    pub unsafe fn SetVolumeThreshold(&mut self, threshold: f32) {
        PtDyWa_SetVolumeThreshold(self, threshold)
    }
    #[inline]
    pub unsafe fn new(step: ::std::os::raw::c_uint) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        PtDyWa_PtDyWa(__bindgen_tmp.as_mut_ptr(), step);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    pub fn Analyzer_Create(step: ::std::os::raw::c_uint) -> *mut Analyzer;
}
extern "C" {
    pub fn Analyzer_Free(analyzer: *mut Analyzer);
}
extern "C" {
    pub fn Analyzer_InputFloat(
        analyzer: *mut Analyzer,
        data: *mut f32,
        sampleCt: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Analyzer_InputShort(
        analyzer: *mut Analyzer,
        data: *mut ::std::os::raw::c_short,
        sampleCt: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Analyzer_InputByte(
        analyzer: *mut Analyzer,
        data: *mut ::std::os::raw::c_char,
        sampleCt: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Analyzer_Process(analyzer: *mut Analyzer);
}
extern "C" {
    pub fn Analyzer_GetPeak(analyzer: *mut Analyzer) -> f32;
}
extern "C" {
    pub fn Analyzer_FindNote(analyzer: *mut Analyzer, minFreq: f64, maxFreq: f64) -> f64;
}
extern "C" {
    pub fn Analyzer_OutputFloat(
        analyzer: *mut Analyzer,
        data: *mut f32,
        sampleCt: ::std::os::raw::c_int,
        rate: f32,
    ) -> bool;
}
extern "C" {
    pub fn PtAKF_Create(step: ::std::os::raw::c_uint) -> *mut PtAKF;
}
extern "C" {
    pub fn PtAKF_Free(analyzer: *mut PtAKF);
}
extern "C" {
    pub fn PtAKF_GetNumHalfTones() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_PtAKF_SetVolumeThreshold"]
    pub fn PtAKF_SetVolumeThreshold1(analyzer: *mut PtAKF, threshold: f32);
}
extern "C" {
    pub fn PtAKF_GetVolumeThreshold(analyzer: *mut PtAKF) -> f32;
}
extern "C" {
    pub fn PtAKF_InputByte(
        analyzer: *mut PtAKF,
        data: *mut ::std::os::raw::c_char,
        sampleCt: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_PtAKF_GetNote"]
    pub fn PtAKF_GetNote1(
        analyzer: *mut PtAKF,
        maxVolume: *mut f32,
        weights: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PtDyWa_Create(step: ::std::os::raw::c_uint) -> *mut PtDyWa;
}
extern "C" {
    pub fn PtDyWa_Free(analyzer: *mut PtDyWa);
}
extern "C" {
    pub fn PtDyWa_SetVolumeTreshold(analyzer: *mut PtDyWa, threshold: f32);
}
extern "C" {
    pub fn PtDyWa_GetVolumeThreshold(analyzer: *mut PtDyWa) -> f32;
}
extern "C" {
    pub fn PtDyWa_InputByte(
        analyzer: *mut PtDyWa,
        data: *mut ::std::os::raw::c_char,
        sampleCt: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_PtDyWa_FindNote"]
    pub fn PtDyWa_FindNote1(analyzer: *mut PtDyWa, maxVolume: *mut f32) -> f64;
}
